{this is a includeable file, and not a stand alone program.
(C) 2020 D. Collins, Z-80 Dad. Check youtube for detials
this code is provided as is, free to use without warentee
agaist damage or loss.  use at your own risk.  These
procedures make drawing to the screen much simpler with the
PiGFX terminal https://github.com/fbergama/pigfx.  Please
check the extensive documentation for questions useing. look at
graph4.txt to see comments they were getting quite large }

{GRAPH2 V2.75 Small custom graph4 for mbc2tris}
{$V-}

Const
esc = ^['['; {we use this string a lot so it is expressed as constant}
hc = ^['[H'; {Sends the cursor home}
sc = ^['[s'; {saves the cursor pos}
rc = ^['[u'; {returns the cursor to the previously saved location}
csh = ^['[2J'; {clears the screen and returns the cursor home}
cr = ^['[m'; {reset's color attributes to black on white}
ic = ^['[?25l'; {turn off the cursor}
vc = ^['[?25h'; {turn on the cursor}
bc = ^['[?25b'; {blink the cursor, flip back with vc}

SerialTXPort = 1; {TX port address for OPCode under Z80MBC2 see
                   notes in arduino sketch comments}
startoffset = 32;    {bitmap font of starts at}
startnumoffset = 15; {reduced numbers only character set starts at}
             { these values are to a certain extent hard coded to
               the print statements, which will need to be changed
               to actually move the character sets. the standard set is
               32 - 126, the numbers only set is 15-31 and is reffenced
               useing a pregenerated array defined by setconvtable
               procedure useing both sets leaves you with 18 bitmaps
               for sprites or whatever, useing just the numbers leaves
               112 - at some point i will make the tables work for all
               functions which will allow moveing the sets around }
type
 WorkString = string[255];
 NumString = string[3];
 ColData = string[10];
 wkstring = string[2];
 outstring = string[8];
 rgbstring = string[6];

var
 statement : string[255];
 ColRawStr : ColData;
 ColDataPt1,ColDataPt2 : integer; (* pull out as globals for use outside of unit *)

 { quick and dirty look up table for secondary font generated by
   loading the numbers only font. }

 convtbl : array[32..127] of integer;

{ generates the look up table for secondary font }
procedure setconvtable;
var
  a,b :integer;
begin
 for a:= 32 to 127 do convtbl[a] := 15;
 b := 15;
 for a:= 48 to 57 do
  begin
   convtbl[a] := b; (* 0-9 *)
   b := b+1;
  end;
 b := 25;
 for a:= 65 to 70 do
  begin
   convtbl[a] := b; (* A-F for HEX support *)
   b := b+1;
  end;
 b := 25;
 for a:= 97 to 102 do
  begin
   convtbl[a] := b; (* a-f for lowercase, this conv. to upcase *)
   b := b+1;
  end;
end;

{converts 2 character hex string to a binary value string}
function hextobin(var hexstring :wkstring)  : outstring;
var
 C1,C2 : integer;
 out : outstring;
begin
 C1 := ord(hexstring[1]);
 C2 := ord(hexstring[2]);
 if C1 > 90 then
  begin
   C1 := C1 - 32;
   hexstring[1] := chr(C1); (* check for upper case *)
  end;
 if C2 > 90 then
  begin
   C2 := C2 - 32;
   hexstring[2] := chr(C2);
  end;
 case hexstring[1] of
  '0' : out := '0000';
  '1' : out := '0001';
  '2' : out := '0010';
  '3' : out := '0011';
  '4' : out := '0100';
  '5' : out := '0101';
  '6' : out := '0110';
  '7' : out := '0111';
  '8' : out := '1000';
  '9' : out := '1001';
  'A' : out := '1010';
  'B' : out := '1011';
  'C' : out := '1100';
  'D' : out := '1101';
  'E' : out := '1110';
  'F' : out := '1111';
 end;
 case hexstring[2] of
  '0' : hextobin := out + '0000';
  '1' : hextobin := out + '0001';
  '2' : hextobin := out + '0010';
  '3' : hextobin := out + '0011';
  '4' : hextobin := out + '0100';
  '5' : hextobin := out + '0101';
  '6' : hextobin := out + '0110';
  '7' : hextobin := out + '0111';
  '8' : hextobin := out + '1000';
  '9' : hextobin := out + '1001';
  'A' : hextobin := out + '1010';
  'B' : hextobin := out + '1011';
  'C' : hextobin := out + '1100';
  'D' : hextobin := out + '1101';
  'E' : hextobin := out + '1110';
  'F' : hextobin := out + '1111';
 end;
end;

{ functions exactly as inkey in mbasic, this outputs the ordinal value of
 the key that was pressed, a debounce delay of 1ms is recommended prior to
 calling this function }

function inkey : integer;
var 
 iobyte : byte;
begin
 {if bios(1) = 255 then inkey := bios(2) else inkey :=0;}
 iobyte := port[1];
 if iobyte = 255 then inkey := 0 else inkey := iobyte;
end;

{A simple function to convert a 3 digit number to a string in line}
function NumStr(Var I:Integer) : NumString;
Var S : NumString;
begin
 str(I,S);
 NumStr := S;
End;

{intertal routine which sends a string directly to the terminal,
has a hard character limit of 255 }
procedure piout(var LineToSend: WorkString);
var
 stlength,counter :integer;
 carval: char;

begin
 for counter := 1 to length(LineToSend) do (* send each character 1 at a time *)
  begin
   port[1] := SerialTXPort; (* select the OPCode *)
   port[0] := ord(LineToSend[counter]); (* data for op code *)
  end;
end;

{test routine to chage palette 0 - default, 1 - VGA(mode 13h), 2 - custom, 3 - C64}
procedure SetPalette(gfxpal: integer);
begin
 statement := esc + '=' + NumStr(gfxpal) + 'p';
 piout(statement);
end;

{set mode to grapics see README_ADD.md in PiGFX repository}
procedure SetModeGFX(gfxmode,fontmode,drawmode: integer);
begin
  statement := esc + '=' + NumStr(gfxmode) + 'h' + esc + '=' + NumStr(fontmode) + 'f';
  statement := statement + esc + NumStr(drawmode) + 'm' + ic;
  piout(statement);
end;

{sets back to default console mode}
procedure SetModeText;
begin
  statement := esc + '=3h' + esc + '=0m' + vc + cr;
  piout(statement);
  SetPalette(0);
end;

{draws a rectangle starting at x,y 0 of w/h}
{fill bit '1' to fill '0' to not fill}
procedure GFXDrawRectangle (x,y,w,h,f :integer);
begin
 case f of

  0 : begin
       statement := esc + '#' + NumStr(x) + ';' + NumStr(y) + ';' + NumStr(w) + ';' + NumStr(h) + 'R';
       piout(statement);
      end;
  1 : begin
       statement := esc + '#' + NumStr(x) + ';' + NumStr(y) + ';' + NumStr(w) + ';' + NumStr(h) + 'r';
       piout(statement);
      end;
 end;
end;


{set forgroud color see:
 https://en.wikipedia.org/wiki/file:Xterm_256color_chart.svg}
{home cursor bit 1 = home 0 = no - this functionality is depreciated but left
 in for compatablility}
procedure GFXSetColorFG(color,cs: integer);
begin
 statement := esc + '38;5;' + NumStr(color) + 'm';
 piout(statement);
end;

{set backgroud color see fg color function for url}
{home and clear bit 1 = clear, 0= no}
procedure GFXSetColorBG(color,cs: integer);
begin
 case cs of
  1 : begin
       statement := esc + '48;5;' + NumStr(color) + 'm' + csh;
       piout(statement);
      end;
  0 : begin
       statement := esc + '48;5;' + NumStr(color) + 'm';
       piout(statement);
      end;
 end;
end;

{load the maximite pallet}
Procedure GFXLoadMaxPal(fg,bg,fga,bga :integer);
var
 fgcolor,bgcolor,fgacolor,bgacolor : string[6];
begin
   case fg of
    0 : fgcolor := '000000';
    1 : fgcolor := '0000FF';
    2 : fgcolor := '00FF00';
    3 : fgcolor := '00FFFF';
    4 : fgcolor := 'FF0000';
    5 : fgcolor := 'FF00FF';
    6 : fgcolor := 'FFFF00';
    7 : fgcolor := 'FFFFFF';
   end;
   case bg of
    0 : bgcolor := '000000';
    1 : bgcolor := '0000FF';
    2 : bgcolor := '00FF00';
    3 : bgcolor := '00FFFF';
    4 : bgcolor := 'FF0000';
    5 : bgcolor := 'FF00FF';
    6 : bgcolor := 'FFFF00';
    7 : bgcolor := 'FFFFFF';
   end;
   case fga of
    0 : fgacolor := '000000';
    1 : fgacolor := '0000FF';
    2 : fgacolor := '00FF00';
    3 : fgacolor := '00FFFF';
    4 : fgacolor := 'FF0000';
    5 : fgacolor := 'FF00FF';
    6 : fgacolor := 'FFFF00';
    7 : fgacolor := 'FFFFFF';
   end;
   case bga of
    0 : bgacolor := '000000';
    1 : bgacolor := '0000FF';
    2 : bgacolor := '00FF00';
    3 : bgacolor := '00FFFF';
    4 : bgacolor := 'FF0000';
    5 : bgacolor := 'FF00FF';
    6 : bgacolor := 'FFFF00';
    7 : bgacolor := 'FFFFFF';
   end;
   statement := esc + '=16;12p000000;0000FF;00FF00;00FFFF;FF0000;FF00FF;FFFF00;';
   statement := statement + 'FFFFFF;' + fgcolor + ';' + bgcolor + ';' + fgacolor + ';';
   statement := statement + bgacolor + ';';
   piout(statement); {send the above pallet to the pi, it is the maximite pallet
                      + fg/bg color for bit map font at 8 and 9 respectively,
                      the 10 and 11 colors are the alternitive font}
   setpalette(2);
   GFXSetColorFG(7,0); {sets defalult fg to white, as it is different in the Maximite}
end;


{ a print statement that is similar to the maximite bitmap mode print
  currently no way to ajust color }
procedure bprint(x,y :integer ; ipstring :WorkString);
var
 i,val : integer;
begin
 for i := 1 to length(ipstring) do
  begin
    val := ord(ipstring[i]);
    statement := esc + '#' +NumStr(val)+ ';' + NumStr(x) + ';' + NumStr(y) + 'd';
    piout(statement);
    x := x + 8;
  end;
end;

{prints with the secondary character set}
procedure bprint2(x,y :integer; ipstring :WorkString);
var
 i,b,val :integer;
begin
 for i := 1 to length(ipstring) do
  begin
   val := convtbl[ord(ipstring[i])];
   statement := esc + '#' +NumStr(val)+ ';' + NumStr(x) + ';' +  NumStr(y) + 'd';
   piout(statement);
   x := x+8;
  end;
end;

{prints useing col and row configureation}
procedure mprint(c,r :integer ; instring:WorkString);
var
 x,y :integer;
begin
 x := c*8;
 y := r*8;
 bprint(x,y,instring);
end;

procedure mprint2(c,r :integer; instring:WorkString);
var
 x,y :integer;
begin
 x := c*8;
 y := r*8;
 bprint2(x,y,instring);
end;
